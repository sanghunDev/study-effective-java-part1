# 아이템 15 클래스와 멤버의 접근 권한을 최소화하라
## 핵심 정리
### 구현과 API 를 분리하는 정보은닉의 장점
* 시스템 개발 속도를 높인다
  * 개발자가 여러명이라면 여러 컴포넌트를 병렬로 개발 가능하기 때문
* 시스템 관리 비용을 낮춘다
  * 컴포넌트를 더 빨리 파악이 가능하기 때문
* 성능 최적화에 도움을 준다
  * 프로파일링을 통해 최적화할 컴포넌트를 찾을 수 있다
  * 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 개선할 수 있다
* 독자적인 컴포넌트라면 소프트웨어 재사용성을 높인다
* 시스템 개발 난이도를 낮춘다
  * 전체를 만들기 전에 개별로 컴포넌트 검증을 할 수 있기 때문

### 클래스와 인터페이스의 접근 제한자 사용 참고
* 모든 클래스와 멤버의 접근성을 가능한 좁히자
* 톱 레벨 클래스와 인터페이스에 package-private, public 을 사용할 수 있다
  * public 으로 선언하려면 API 가 되기 때문에 하위 호환성을 유지하려면 영원히 관리해야 한다
    * 하위 호환성 때문에 한번 공유된 클래스를 변경 시 클라이언트에서 여러 문제점이 생길 수 있기 때문에 변경하기가 힘들다
    * 하위 호환성을 지키려는 노력 자체는 좋지만 유지관리가 힘들다
      * 버전관리만 잘 한다면 하위 호환성을 깨고 대대적인 변경도 괜찮을 수 있다
  * 패키지 외부에서 쓰지 않을 클래스나 인터페이스라면 package-private 으로 선언한다
* 한 클래스에서만 사용하는 package-private 클래스나 인터페이스는 해당 클래스에 private static 으로 중첩 시키자

### 멤버(필드, 메서드, 중첩 클래스/인터페이스)의 접근 제한자 원칙
* private, package-private 은 내부 구현
  * 숨길 정보기 때문에 내부에서 구현
* public 클래스의 protected 와 public 은 공개 API
  * 공개할 목적으로 사용하는 경우에 해당 접근 제한자를 사용하자
* 코드를 테스트 하는 목적으로 private 를 package-private 으로 풀어주는것은 허용 가능
  * 단, 테스트만을 위해서 멤버를 공개 API 로 만들어서는 안된다
    * 기존에 getter 를 제공 한다면 사용해도 ok
    * 필드를 꼭 private 로 유지하고 싶다면 getter 를 제공해서 사용해도 괜찮다
  * 테스트를 같은 패키지에 만든다면 테스트 만을 위해 공개 API 로 바꾸지 않아도 된다
    * 인스턴스 생성을 위해서 실제 객체는 아니지만 같은 패키지로 만들지 않고 Mocking 으로 처리해도 된다
* public 클래스의 인스턴스 필드는 되도록 public 이 아니어야 한다
  * 상수는 괜찮지만 나머지는 되도록이면 public 이 아니게 제공
* 클래스에서 public static final 배열 필드를 사용하거나 반환하는 접근자 메서드를 제공해서는 안된다

## 완벽 공략
### java9 모듈 JavaPlatformModuleSystem
* JSR-376 스팩으로 정의한 자바의 모듈 시스템
  * 모듈끼리는 캡슐화가 잘 지켜지지만 모듈이 아닌 경우에는 그냥 사용이 가능하다는 단점이 존재한다
  * 실제로 잘 사용되지 않는 기능이다
* 모듈내에서 어떤 패키지를 참조 및 공개할지 정의를 가능하다
  * 컴포넌트간의 관계를 표현 가능해서 클래스 패스로만 지정하는 방식보다 안전하다
* 안정성
  * 순환 참조를 허용하지 않는다
  * 실행시 필요한 모듈을 확인한다
  * 한 패키지는 한 모듈에서만 공개할 수 있다
* 캡슐화
  * public 인터페이스나 클래스라 하더라도 공개된 패키지만 사용할 수 있다
  * 내부 구현을 보호하는 수단으로 사용 가능하다
* 확장성
  * 필요한 자바 플랫폼 모듈만 모아서 최적의 JRE 를 구성할 수 있다
  * 작은 기기에서 구동할 애플리케이션을 개발시 유용하다
