# 아이템 10 equals 는 일반 규약을 지켜 재정의하라
## 핵심 정리
* equals 를 재정의 하지 않는것이 최선이다
### equals 가 필요없는 경우
* 아래의 경우에는 equals 를 재정의 할 필요가 없다
  * 각 인스턴스가 본질적으로 고유하다
    * 싱글톤, Enum 등.. 각 인스턴스 자체가 본질적으로 고유한 경우 
  * 인스턴스의 논리적 동치성을 검사할 필요가 없다
    * 논리적인 동치성이란 비교할 두 대상의 핵심 값을 뜻한다
  * 상위 클래스에서 재정의한 equals 가 하위 클래스에도 적절하다
  * 클래스가 private 또는 package-private 이고 equals 메서드를 호출할 일이 없다
    * 밖에서 마음대로 참조해서 사용할 수 없기 때문에 필요가 없다

### equals 규약
* 반사성
  * A.equals(A) == true
  * 객체는 자기 자신과 같아야 한다
  * 인스턴스가 들어있는 컬렉션에 contains 호출 시 true
* 대칭성
  * A.equals(B) == B.equals(A)
  * 서로에 대한 동치 여부에 똑같은 결과가 나와야 한다
    * 둘 다 결과가 같아야 하며 어느 한쪽의 결과가 다르면 안된다
* 추이성
  * A.equals(B) && B.equals(C) && A.equals(C) 
  * 첫번째 객체와 두 번째 객체가 같고, 두번째 객체와 세번째 객체가 같다면 첫번째 객체와 세번째 객체도 같아야 한다
    * 동일한 객체간에서는 지키기 쉽지만 확장을 위해 상속클래스가 생기면 어길 확률이 생긴다
  * 문제점
    * 구체 클래스를 확장해서 필드를 추가하면 추이성과 대칭성이 깨진다
  * 해결방안
    * 상속이 아닌 컴포지션을 사용해서 자기 자신을 확인 후 자기 자신의 컴포지션으로 받은 필드를 확인해서 해결 가능하다 
* 일관성
  * A.equals(B) == A.equals(B)
  * 두 객체가 같다면 영원히 같아야 한다
    * 시간, 호출 횟수 등에 따라서 결과가 달라지면 안된다
  * 불변 객체라면 일관성은 항상 유지된다
  * 가변 객체라면 깨질 수 있다
  * 일관성을 지키려면 너무 복잡하게 구현하면 안된다
* Null-아님
  * 모든 객체는 null 과 같으면 안된다
  * 즉 어떠한 A.equals(null) == false
    * 당연히 NPE 도 발생하면 안된다

### equals 구현 방법
* == 연산자를 사용해서 자기 자신의 참조인지 확인한다
* instanceof 연산자로 올바른 타입인지 확인한다
* 입력된 값을 올바른 타입으로 형변환 한다
* 입력 객체와 자기 자신의 대응되는 핵심 필드가 일치하는지 확인한다
* 위 조건들을 만족해서 구현하기 어렵기 때문에 아래와 같은 방법을 사용한다
  * 구글의 AutoValue
    * 정석적인 어노테이션 프로세서 방식으로 동작하지만 사용하기가 굉장히 불편하다
    * 여러가지 규약을 지켜야 한다
  * Lombok
    * 상대적으로 사용하기 간편하기 때문에 가장 많이 사용한다
    * 어노테이션 프로세서를 사용하긴 하지만 기존의 코드를 뜯어서 고치는 방식이라 일종의 해킹이라고 볼 수도 있다
  * IDE 의 코드 생성 기능을 사용한다
    * 코드가 지저분하고 필드가 늘어나면 해당 직접 고쳐줘야 한다 
  * record
    * java14 에 도입, LTS 인 java17에서 주로 사용
    * 보일러 플레이트 코드를 사용하지 않아도 괜찮다
      * 컴파일러에서 equals, hashCode, toString, final 필드, public 생성자를 자동으로 만들어 준다
    * DTO 등을 만들때 반복적으로 사용되는 코드를 줄일 수 있어서 편리하다

### equals 구현시 주의사항
* equals 를 재정의 할 때 hashCode 도 반드시 재정의하자
* 너무 복잡하게 해결하려고 하지 말자
  * 값들을 비교할 때 너무 복잡하게 하려고 하지 말라는 것
* Object 가 아닌 타입의 매개변수를 받는 equals 메서드는 선언하지 말자
  * equals 메서드를 재정의 하는 경우 파라미터가 Object 가 아닌것으로 변경하지 말자

## 완벽 공략
### Value 기반의 클래스
* 클래스 처럼 생겼지만 int 처럼 동작하는 클래스
* 식별자가 없고 불변이다
  * 해당 객체만의 식별자가 있으면 안된다
  * 생성된 객체는 변할 수 없다
* 식별자가 아니라 인스턴스가 가지고 있는 상태를 기반으로 equals, hashCode, toString 을 구현한다
* == 오퍼레이션이 아니라 equals 를 사용해서 동등성을 비교한다
* 동일한(equals) 객체는 상호교환 가능하다
* java17 부터는 record 를 쓰는게 적절한 선택이다