# 아이템 10 equals 는 일반 규약을 지켜 재정의하라
## 핵심 정리
* equals 를 재정의 하지 않는것이 최선이다
### equals 가 필요없는 경우
* 아래의 경우에는 equals 를 재정의 할 필요가 없다
  * 각 인스턴스가 본질적으로 고유하다
    * 싱글톤, Enum 등.. 각 인스턴스 자체가 본질적으로 고유한 경우 
  * 인스턴스의 논리적 동치성을 검사할 필요가 없다
    * 논리적인 동치성이란 비교할 두 대상의 핵심 값을 뜻한다
  * 상위 클래스에서 재정의한 equals 가 하위 클래스에도 적절하다
  * 클래스가 private 또는 package-private 이고 equals 메서드를 호출할 일이 없다
    * 밖에서 마음대로 참조해서 사용할 수 없기 때문에 필요가 없다

### equals 규약
* 반사성
  * A.equals(A) == true
  * 객체는 자기 자신과 같아야 한다
  * 인스턴스가 들어있는 컬렉션에 contains 호출 시 true
* 대칭성
  * A.equals(B) == B.equals(A)
  * 서로에 대한 동치 여부에 똑같은 결과가 나와야 한다
    * 둘 다 결과가 같아야 하며 어느 한쪽의 결과가 다르면 안된다
* 추이성
  * A.equals(B) && B.equals(C) && A.equals(C) 
  * 첫번째 객체와 두 번째 객체가 같고, 두번째 객체와 세번째 객체가 같다면 첫번째 객체와 세번째 객체도 같아야 한다
    * 동일한 객체간에서는 지키기 쉽지만 확장을 위해 상속클래스가 생기면 어길 확률이 생긴다
  * 문제점
    * 구체 클래스를 확장해서 필드를 추가하면 추이성과 대칭성이 깨진다
  * 해결방안
    * 상속이 아닌 컴포지션을 사용해서 자기 자신을 확인 후 자기 자신의 컴포지션으로 받은 필드를 확인해서 해결 가능하다 
* 일관성
  * A.equals(B) == A.equals(B)
  * 두 객체가 같다면 영원히 같아야 한다
    * 시간, 호출 횟수 등에 따라서 결과가 달라지면 안된다
  * 불변 객체라면 일관성은 항상 유지된다
  * 가변 객체라면 깨질 수 있다
  * 일관성을 지키려면 너무 복잡하게 구현하면 안된다
* Null-아님
  * 모든 객체는 null 과 같으면 안된다
  * 즉 어떠한 A.equals(null) == false
    * 당연히 NPE 도 발생하면 안된다