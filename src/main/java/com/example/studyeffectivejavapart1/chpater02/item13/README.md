# 아이템 13 clone 재정의는 주의해서 진행해라
## 핵심 정리
* 복사를 하기 위해서는 Cloneable 인터페이스 구현 후 오버라이드 필요
### 애매모호한 clone 규약
* clone 규약
* x.clone() != x
  * 반드시 true
  * 반드시 다른 객체여야된다
* x.clone().getClass() == x.getClass()
  * 반드시 true
  * 복사한 클래스와 원본 클래스가 같아야 한다
* x.clone().equals(x)
  * true 가 아닐 수 있음
  * equals 를 하는 경우 같을수도 있고 다를 수도 있다
    * 다른 필드 값을 셋팅 하는 경우도 있기 때문
* 불변 객체라면 다음으로 충분
  * Cloneable 인터페이스를 구현
    * clone 메서드를 재정의, 이때 super.clone 을 사용

### 가변 객체의 clone 구현하는 방법
* 접근 제한자는 public, 반환 타입은 자신의 클래스로 변경한다
* super.clone 을 호출한 뒤 필요한 필드를 적절히 수정한다
  * 배열을 복제할 때는 배열의 clone 메서드를 사용하라
    * 단순하게 clone 을 사용해서 복사
  * 경우에 따라 final 을 사용할 수 없을지도 모른다
  * 필요한 경우 deep copy 를 해야한다
    * 원본가는 별도로 가지고 있는 배열도 달라지게 하기 위해서 deep copy 를 실시해야 한다
    * deep copy 시 재귀적인 방식이 아닌 반복문을 사용해서 만드는게 더 안전하다
      * 재귀시 stack over flow 의 위험이 있음 
  * super.clone 으로 객체를 만들고 고수준 메서드를 호출하는 방법도 있다
    * 외부 공개되어 있는 public 하게 공개되어 있는 get, put 등 의 메서드를 사용하는 방법
  * 오버라이딩 할 수 있는 메서드는 참조하지 않도록 조심해야 한다
    * 재정의 할 수 있는 메서드가 있으면 하위 클래스에서 재정의 시 동작이 변할 수 있다
  * 상속용 클래스는 Cloneable 을 구현하지 않는 것이 좋다
    * 상속용 클래스에 Cloneable 이 사용되어 있으면 확장시 clone 에 관한 불필요한 고민을 해야하게 된다
    * 하위 클래스에서 구현을 하지 않도록 직접 구현해서 막는 방법이 있다
      * final 및 throw 발생 등..
  * Cloneable 을 구현한 스레드 안전 클래스를 작성할 때는 동기화를 해야 한다
    * 멀티쓰레드에서 안전하게 사용되어야 한다면 synchronized 를 사용하자

### clone 대안
* 위와 같이 가변 객체에 대해 clone 을 사용하는 경우 고려해야 하는 점이 매우 많다
* 복사 생성자 또는 변환 생성자, 복사 팩터리 또는 변환 팩토리를 사용하자
  * 생성자를 사용해서 객체를 새로 생성하는 방법을 권장한다
    * 복사용 팩토리 메서드를 제공할수도 있다
  * 생성자를 사용하면 계층 구조에도 유리하다
    * 사용자가 원하는 하위 타입으로의 변환도 가능하다
      * 클라이언트가 복제본의 타입을 결정할 수 있다
    * 가변 객체에 대한 clone 에서 final 을 못 쓰는 것과 다르게 final 키워드를 사용 가능하다

## 완벽 공략
### UnChecked Exception (비검사예외)
* 왜 비검사 예외를 선호하는가?
  * 컴파일 에러를 신경 쓰지 않아도 된다
  * try-catch 로 감싸거나 메서드 선언부에 선언하지 않아도 괜찮다
    * 하지만 편리하다는 이유만으로 비검사 예외를 쓴다고 생각하면 안된다
* 언제 검사, 비검사 예외를 사용할까?
  * 클라이언트가 해당 예외 상황을 복구할 수 있다면 검사 예외를 사용
  * 해당 예외가 발생시 아무것도 할 수 없을 경우 비검사 예외로 만든다
* 비검사 예외는 왜 강제하지 않는가?
  * 비검사 예외는 복구할 수 없다고 판단하기 때문이다
  * 즉 클라이언트가 무언가 할 수 없기 때문에 강제하지 않는다
* 검사 예외는 왜 있을까?
  * 검사 예외가 있는 이유는 해당 예외 자체가 API 라고 볼 수 있다
  * 즉 클라이언트에게 어떤 예외가 발생할 수 있으니 대응을 하라고 알려줄때 사용한다

### TreeSet
* AbstractSet 을 확장한 정렬된 컬렉션이다
* TreeSet 의 특징
  * Set 의 성질과 같이 객체를 중복해서 저장할 수 없고 저장 순서가 중요하지 않다
  * HashSet 과는 다르게 이진 탐색 트리(BinarySearchTree) 구조로 이루어져 있다
    * 그 중에서도 Red-Black Tree 를 사용한다
    * 이진 탐색 트리는 추가와 삭제에 시간이 걸리고 정렬, 검색에 높은 성능을 보이는 자료구조
    * 즉 HashSet 보다 추가와 삭제에는 시간이 더 걸리지만 검색과 정렬에는 유리하다
  * 엘리먼트를 추가한 순서를 중요하지 않다
  * 엘리먼트가 지닌 자연적인 순서(natural order)에 따라 정렬하게 된다
  * 오름차순으로 정렬한다
  * 멀티 스레드 환경에서 안전하지 않다
* 레드-블랙 트리 (Red-Black Tree)
  * 일반적인 이진 탐색 트리는 트리의 높이만큼 시간이 걸리기 때문에 한쪽으로 편향된 데이터가 들어오면 굉장히 비효율적이다
  * 이러한 문제점을 개선하기 위해 나온게 레드-블랙 트리이다
  * 레드-블랙 트리의 특징
    * 부모 노드보다 작은 값을 가지는 노드는 왼쪽 자식으로 보낸다
    * 부모 노드보다 큰 값을 가지는 노드는 오른쪽 자식으로 배치한다
    * 이렇게 분배함에 따라서 데이터의 추가, 삭제 시 트리가 한쪽으로 치우쳐지지 않도록 균형을 맞춰준다
