# 아이템 13 clone 재정의는 주의해서 진행해라
## 핵심 정리
* 복사를 하기 위해서는 Cloneable 인터페이스 구현 후 오버라이드 필요
### 애매모호한 clone 규약
* clone 규약
* x.clone() != x
  * 반드시 true
  * 반드시 다른 객체여야된다
* x.clone().getClass() == x.getClass()
  * 반드시 true
  * 복사한 클래스와 원본 클래스가 같아야 한다
* x.clone().equals(x)
  * true 가 아닐 수 있음
  * equals 를 하는 경우 같을수도 있고 다를 수도 있다
    * 다른 필드 값을 셋팅 하는 경우도 있기 때문
* 불변 객체라면 다음으로 충분
  * Cloneable 인터페이스를 구현
    * clone 메서드를 재정의, 이때 super.clone 을 사용

### 가변 객체의 clone 구현하는 방법
* 접근 제한자는 public, 반환 타입은 자신의 클래스로 변경한다
* super.clone 을 호출한 뒤 필요한 필드를 적절히 수정한다
  * 배열을 복제할 때는 배열의 clone 메서드를 사용하라
    * 단순하게 clone 을 사용해서 복사
  * 경우에 따라 final 을 사용할 수 없을지도 모른다
  * 필요한 경우 deep copy 를 해야한다
    * 원본가는 별도로 가지고 있는 배열도 달라지게 하기 위해서 deep copy 를 실시해야 한다
    * deep copy 시 재귀적인 방식이 아닌 반복문을 사용해서 만드는게 더 안전하다
      * 재귀시 stack over flow 의 위험이 있음 
  * super.clone 으로 객체를 만들고 고수준 메서드를 호출하는 방법도 있다
    * 외부 공개되어 있는 public 하게 공개되어 있는 get, put 등 의 메서드를 사용하는 방법
  * 오버라이딩 할 수 있는 메서드는 참조하지 않도록 조심해야 한다
    * 재정의 할 수 있는 메서드가 있으면 하위 클래스에서 재정의 시 동작이 변할 수 있다
  * 상속용 클래스는 Cloneable 을 구현하지 않는 것이 좋다
    * 상속용 클래스에 Cloneable 이 사용되어 있으면 확장시 clone 에 관한 불필요한 고민을 해야하게 된다
    * 하위 클래스에서 구현을 하지 않도록 직접 구현해서 막는 방법이 있다
      * final 및 throw 발생 등..
  * Cloneable 을 구현한 스레드 안전 클래스를 작성할 때는 동기화를 해야 한다
    * 멀티쓰레드에서 안전하게 사용되어야 한다면 synchronized 를 사용하자

### clone 대안
* 위와 같이 가변 객체에 대해 clone 을 사용하는 경우 고려해야 하는 점이 매우 많다
* 복사 생성자 또는 변환 생성자, 복사 팩터리 또는 변환 팩토리를 사용하자
  * 생성자를 사용해서 객체를 새로 생성하는 방법을 권장한다
    * 복사용 팩토리 메서드를 제공할수도 있다
  * 생성자를 사용하면 계층 구조에도 유리하다
    * 사용자가 원하는 하위 타입으로의 변환도 가능하다
      * 클라이언트가 복제본의 타입을 결정할 수 있다
    * 가변 객체에 대한 clone 에서 final 을 못 쓰는 것과 다르게 final 키워드를 사용 가능하다
