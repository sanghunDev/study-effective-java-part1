# 아이템 3 생성자나 열거 타입으로 싱글턴임을 보장하라
## 핵심 정리
### private 생성자 + public static final 필드
* 장점
  * 코드가 간결하며 싱글턴 여부를 API 에 알려줄 수 있다
    * java doc 을 만드는 경우 잘 나타남
* 단점
  * 싱글톤을 사용하는 클라이언트가 테스트하기 어려워진다
    * 테스트 코드에서 해당 싱글톤을 사용하는 인스턴스를 가짜로 주입하기가 어려워짐
    * 인터페이스가 있어야 해당 코드에 대한 Mocking 이 가능해지며 테스트가 용이해진다
  * 리플렉션으로 private 생성자를 호출 할 수 있다
    * 리플렉션으로 싱글톤을 깨고 인스턴스를 여러개 생성이 가능
    * 생성자 호출시 기존에 인스턴스가 존재한다면 예외 출력을 권장
      * 하지만 코드가 간결해지지 않음
  * 역직렬화 하는 경우 새로운 인스턴스가 생길 수 있다
    * ![img.png](img/img.png)
    * 해당 코드를 직접 구현해서 싱글톤에서 사용할 인스턴스를 넘겨줘야 역직렬화시 싱글톤이 보장된다

### private 생성자 + 정적 팩터리 메서드
* 장점
  * API 변경 없이 싱글턴이 아니게 변경 가능하다
    * 메서드를 통해서 접근하기 때문에 클라이언트 코드의 변경 없이 내부 구현을 변경 가능 
  * 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다
    * 제네릭 싱글톤 팩터리를 사용하면 원하는 타입으로 변환해서 인스턴스를 만들 수 있다
      * 타입을 다르게 생성하면 같은 인스턴스지만 인스턴스끼리 비교할 수 없다
  * 정적 팩터리의 메서드 참조를 공급자(Supplier)로 사용할 수 있다
    * Supplier : Java8 의 함수형 인터페이스
    * ![img.png](img/img_2.png)
* 단점
  * private 생성자 + public static final 필드의 단점과 동일하다

### 열거 타입
* 가장 간결한 방법이며 직렬화와 리플렉션에도 안전하다
* 대부분의 상황에서는 원소가 하나뿐인 Enum 이 싱글턴을 만들기 가장 좋은 방법이다

## 완전 공략
### 메서드 참조
* 메소드 하나만 호출하는 람다 표현식을 줄여쓰는 방법
  * 스테틱 메서드 레퍼런스
    * 스테틱한 메서드를 참조하는 것
  * 인스턴스 메서드 레퍼런스
    * 인스턴스를 생성 후 메서드를 참조하는 것
  * 임의 객체의 인스턴스 메서드 레퍼런스
    * 첫번째 인자가 자기자신이 되는 메서드를 생성 후 클래스 이름으로 메서드를 참조 하는 것 
  * 생성자 레퍼런스
    * 클래스의 생성자를 사용해서 접근하는 것

### 함수형 인터페이스
* 추상 메서드가 하나만 존재하면 함수형 인터페이스로 사용 가능하다
* @FunctionalInterface 어노테이션을 사용하면 추상 메소드가 여러개 존재하면 컴파일시에 오류를 출력해주기 때문에 적극 활용하자
* 대부분은 자바가 제공하는 기본 함수형 인터페이스로 처리 가능하며 특별한 경우만 함수형 인터페이스를 만들어서 사용하자
  * 함수형 인터페이스는 람다 표현식과 메소드 참조에 대한 타겟 타입을 제공한다
  * 타겟 타입은 변수 할당, 메소드 호출, 타입 변환에 활용할 수 있다
  * 자바에서 제공하는 기본 함수형 인터페이스를 익혀두자
    * java.util.function 패키지 내부에 있는 클래스를 모두 알면 좋지만 가장 중요한 4가지를 먼저 알아보자
      * Function<T, R>
        * 특정 타입으로 받고 리턴하는 구조로 이루어져 있다
      * Supplier<T>
        * 받는 인자가 없고 특정 타입으로 리턴만 가능하다
        * 리턴 타입이 Integer 인 경우 사용하면 편리하다
      * Consumer<T>
        * 특정 타입을 받을 수 있고 리턴은 없다
          * 뭔가를 받아서 출력할때 사용한다
      * Predicate<T>
        * 특정 타입을 받아서 boolean 을 반환한다

### 객체 직렬화
* 객체를 바이트스트림으로 상호 변환하는 기술이다
  * 같은 자바 시스템에서의 데이터 전송 및 저장에 최적화 되어 있다 (JVM 환경 전송) 
    * 서블릿 세션, 캐시, 자바 RMI 등.. 
* 바이트 스트림으로 변환 -> 직렬화 , 바이트 스트림을 객체로 변환 -> 역직렬화
* 시스템 적으로 말하면 JVM 의 메모리에 상주 되어 있는 객체 데이터를 바이트 형태로 변환하는 기술과 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM 으로 상주 시키는 형태
  * 바이트스트림으로 변환한 객체를 파일로 저장하거나 네트워크를 통해 다른 시스템으로 전송할 수 있다
  * 직렬화를 하기 위해서는 자바의 기본 타입이거나 Serializable 인터페이스를 상속 받아야 한다 
    * transient 를 사용해서 직렬화 하지 않을 필드를 선언할 수 있다
  * 역직렬화를 하기 위해서는 직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야 하며 import 되어 있어야 한다
  * serialVersionUID 를 사용하는 경우
    * 기본적으로 jvm 에서 serialVersionUID 를 생성하며 클래스의 변경이 일어나면 serialVersionUID 도 변경된다 
    * 클래스 구조 변경 후 역직렬화시 serialVersionUID 가 변경되기 때문에 직렬화 할 클래스에 serialVersionUID 를 선언해서 사용해야한다
    * 즉 직렬화는 클래스 구조가 자주 변경되는 클래스에서는 사용하기가 적합하지 않다