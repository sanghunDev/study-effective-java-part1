# 아이템 7 다 쓴 객체 참조를 해제하라
## 핵심 정리
* 어떤 객체에 대한 레퍼런스가 남아있다면 해당 객체는 가비지 컬렉션의 대상이 되지 않는다
* 자기 메모리를 직접 관리하는 클래스라면 메모리 누수에 주의해야 한다
  * 스택, 캐시, 리스너, 콜백, 어떤 콜렉션에 직접 담는 경우 등.. 메모리 누수의 위험이 있다
* 참조 객체를 null 처리하는 일은 예외적인 경우이다
  * 가장 좋은 방법은 유효 범위 밖으로 밀어내는 것
* 다 쓴 객체 참조를 위한 4가지 방법
  * 사용이 끝나면 직접 null 로 할당 해제
  * WeakHashMap 등 적절한 자료구조를 사용
  * 가장 오래된 객체를 할당 해제 하도록 직접 구현
  * 백그라운드의 쓰레드를 사용해서 주기적으로 클린업을 사용

## 완벽 공략
* NullPointerException
* WeakHashMap
  * 약한 참조 (weak reference)
* 백그라운드 쓰레드
  * ScheduledThreadPoolExecutor

### NullPointerException
* java8 의 Optional 을 활용해서 최대한 NPE 를 피하자
* NPE 가 발생하는 이유
  * 메소드에서 null 을 리턴하거나 null 체크를 하지 않았기 때문
* 메소드에서 적절한 값을 리턴할 수 없는 경우에 선택할 수 있는 방법
  * 예외를 던진다
  * null 을 리턴한다
  * Optional 을 리턴한다

### WeakHashMap
* 더이상 사용하지 않는 객체를 GC 로 메모리 해제시 자동으로 삭제해주는 Map
* Key 가 더이상 강하게 참조되는 곳(레퍼런스 되는 곳)이 없다면 해당 엔트리를 제거한다
* 레퍼런스 종류 4 가지
  * Strong: 직접 new 해서 할당하는 경우
  * Soft: new SoftReference<>(); 생성자 안에 Strong 레퍼런스를 넣어준다
    * 어떤 오브젝트를 Strong 하게 레퍼런스 하는 대상이 없고 Soft 하는 대상만 있다면 GC 의 대상이 된다
      * 단 GC 를 수행한다고 해서 무조건 할당이 해제 되는것이 아닌 메모리가 필요한 상황에만 할당이 해제된다
  * Weak: new WeakReference<>(); 생성자 안에 Strong 레퍼런스를 넣어준다
    * 메모리 공간의 여부와 상관 없이 Strong 하게 레퍼런스 하는 대상이 없다면 무조건 메모리 할당이 해제된다 
  * Phantom: new PhantomReference<>(strong, queue); 생성자 안에 Strong 레퍼런스와 Strong 레퍼런스 타입의 ReferenceQueue 를 넣어준다
    * 해당 객체가 사라짐과 동시에 큐에 들어가게 된다
      * 따라서 언제 이 객체가 사라졌는지 알 수 있다
      * 즉 메모리 해제 시점을 알아야 하는 경우에 사용할 수 있다
    * clear 를 해줘야 최종적으로 사라진다
    * 자원을 반납하는 용도로 사용하려면 PhantomReference 를 상속 받아서 사용해야 한다
* 맵의 엔트리를 맵의 Value 가 아니라 Key 에 의존해야 하는 경우에 사용할 수 있다
* 캐시를 구현하는데 사용할 수 있지만 캐시를 직접 구현하는건 권장하지 않는다